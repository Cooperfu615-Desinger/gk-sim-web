<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>金庫神偷｜RTP 模擬器（含道具／曲線破壞者）</title>
  <style>
    :root{--bg:#0b1020;--card:#141a2d;--muted:#2a3553;--text:#e8ecf3;--sub:#a9b2c7;--accent:#4cc9f0;--ok:#2dd4bf;--warn:#f59e0b;--bad:#ef4444}
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b1020,#0e1630);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    h1,h2,h3{margin:0 0 .5rem}
    a{color:var(--accent)}
    .wrap{max-width:1180px;margin:24px auto;padding:0 16px}
    .grid{display:grid;gap:16px}
    .g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
    .g-2{grid-template-columns:repeat(2,minmax(0,1fr))}
    .card{background:var(--card);border:1px solid var(--muted);border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    label{display:block;font-weight:600;margin-bottom:6px;color:var(--sub)}
    input,textarea,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--muted);background:#0d1326;color:var(--text)}
    textarea{min-height:110px;white-space:pre}
    button{border:0;border-radius:12px;padding:10px 14px;font-weight:700;color:#07111f;background:var(--accent);cursor:pointer}
    button.secondary{background:#263250;color:var(--text)}
    button.ghost{background:transparent;color:var(--text);border:1px dashed var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .muted{color:var(--sub)}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#1d2744;color:#b9c4dc;border:1px solid #2b3860}
    .kpi{font-size:22px;font-weight:800}
    .ok{color:var(--ok)}.warn{color:var(--warn)}.bad{color:var(--bad)}
    .table{width:100%;border-collapse:collapse}
    .table th,.table td{border-bottom:1px solid var(--muted);padding:6px 8px;text-align:right}
    .table th:first-child,.table td:first-child{text-align:left}
    .footnote{font-size:12px;color:#93a0ba}
    .spacer{height:8px}
    .hint{font-size:12px;color:#9fb0cf}
    .error-box{background:#2a1020;border:1px solid #7a294a;color:#ffddea;padding:12px;border-radius:12px;margin:8px 0}
  </style>
</head>
<body>
  <div class="wrap grid g-2">
    <div class="card">
      <h1>金庫神偷｜RTP 模擬器（含道具／曲線破壞者）</h1>
      <p class="muted">單檔網頁（純前端）。提供 <b>自動校準</b>、<b>CSV 匯出</b>、<b>進階模擬</b>與<b>分享連結</b>。</p>
      <div class="row">
        <button id="btnShare" class="secondary">複製目前設定連結</button>
        <button id="btnReset" class="ghost">重設為預設值</button>
        <button id="btnReadme" class="secondary">開啟使用說明 (README)</button>
      </div>
      <div id="errBox" class="error-box" style="display:none"></div>
    </div>

    <div class="card">
      <h3>關於</h3>
      <ul class="muted">
        <li>步數固定 50；Step50 成功率預設 70%</li>
        <li>風險縮放：<span class="pill">odds-scaling</span>（λ₁/λ₂/λ₃）</li>
        <li>校準目標：最佳停步 EV ≈ 0.96</li>
      </ul>
    </div>

    <!-- 左：基礎輸入區 -->
    <div class="card">
      <h2>輸入設定（基礎＋上限）</h2>
      <div class="grid g-2">
        <div>
          <label>目標 RTP</label>
          <input id="inpTarget" type="number" step="0.0001" min="0" max="5" value="0.96" />
        </div>
        <div>
          <label>Step50 成功率（0~1）</label>
          <input id="inpS50" type="number" step="0.01" min="0" max="1" value="0.7" />
        </div>
        <div>
          <label>金額上限（$）</label>
          <input id="inpMoneyCap" type="number" step="100" value="50000" />
        </div>
        <div>
          <label>倍率上限（x）</label>
          <input id="inpMultCap" type="number" step="100" value="5000" />
        </div>
      </div>
      <div class="spacer"></div>
      <label>50 步倍率（逗號或換行分隔）</label>
      <textarea id="inpRewards" class="mono"></textarea>
      <div class="spacer"></div>
      <label>基準失敗率 %（前 49 步；第 50 步自動由成功率推），逗號或換行</label>
      <textarea id="inpBaseFail" class="mono"></textarea>
      <div class="row" style="margin-top:10px">
        <button id="btnCalibrate">自動校準（基礎＋上限）</button>
        <button id="btnExportSpec" class="secondary">匯出規格 CSV</button>
        <button id="btnExportAlerts" class="secondary">匯出警戒 CSV</button>
      </div>
      <p class="hint">校準時使用等效倍率上限：min(倍率上限, 金額上限 / 1)。</p>
    </div>

    <!-- 右：進階模擬 -->
    <div class="card">
      <h2>進階模擬（道具／曲線破壞者）</h2>
      <div class="grid g-3">
        <div>
          <label>下注額（$）</label>
          <input id="inpBet" type="number" step="0.1" value="1" />
        </div>
        <div>
          <label>模擬局數</label>
          <input id="inpSims" type="number" step="1000" value="20000" />
        </div>
        <div></div>
        <div>
          <label>λ1（步 1–30）</label>
          <input id="inpLam1" type="number" step="0.01" value="1.0" />
        </div>
        <div>
          <label>λ2（步 31–40）</label>
          <input id="inpLam2" type="number" step="0.01" value="1.12" />
        </div>
        <div>
          <label>λ3（步 41–50）</label>
          <input id="inpLam3" type="number" step="0.01" value="2.5" />
        </div>
      </div>

      <div class="spacer"></div>
      <h3>道具 / 破壞者 參數</h3>
      <div class="grid g-3">
        <div>
          <label>高級(絕佳) 機率</label>
          <input id="inpCanvasProb" type="number" step="0.01" value="0.08" />
        </div>
        <div>
          <label>高級(絕佳) 加成 (x)</label>
          <input id="inpCanvasBonus" type="number" step="0.1" value="1.0" />
        </div>
        <div></div>
        <div>
          <label>華麗(地標) 機率</label>
          <input id="inpLandmarkProb" type="number" step="0.001" value="0.01" />
        </div>
        <div>
          <label>華麗(地標) 失敗率</label>
          <input id="inpLandmarkFail" type="number" step="0.01" value="0.75" />
        </div>
        <div>
          <label>華麗(地標) 獎勵 (x)</label>
          <input id="inpLandmarkBonus" type="number" step="10" value="1000" />
        </div>
        <div>
          <label>防爆盾(把風) 成本 ×bet</label>
          <input id="inpLookoutCost" type="number" step="0.05" value="0.5" />
        </div>
        <div>
          <label>聽診器(無人機) 成本 ×bet</label>
          <input id="inpDroneCost" type="number" step="0.05" value="0.5" />
        </div>
        <div>
          <label>精密工具(噴頭) 成本 ×bet</label>
          <input id="inpNozzleCost" type="number" step="0.05" value="0.4" />
        </div>
        <div>
          <label>破解器(模版) 成本 ×bet</label>
          <input id="inpTemplateCost" type="number" step="0.05" value="0.6" />
        </div>
        <div>
          <label>後段 +絕對風險 (40–49)</label>
          <input id="inpPost40Bump" type="number" step="0.01" value="0.05" />
        </div>
        <div>
          <label>最小失敗率 (≥45)</label>
          <input id="inpMinFailAfter45" type="number" step="0.01" value="0.35" />
        </div>
        <div>
          <label>下注額上限係數 α</label>
          <input id="inpAlphaByBet" type="number" step="0.05" value="0.5" />
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnRunAdv">執行進階模擬</button>
        <button id="btnCalibAdv" class="secondary">進階自動校準到 96%</button>
      </div>
      <div id="advResult" class="row" style="margin-top:12px"></div>
      <p class="footnote">提示：把任一數值設為 0 即可快速停用該功能（例如華麗(地標) 機率=0）。</p>
    </div>

    <!-- 下：結果與表格 -->
    <div class="card" style="grid-column:1 / -1">
      <h2>校準結果（基礎＋上限）</h2>
      <div id="calibKPI" class="row" style="gap:24px"></div>
      <div class="spacer"></div>
      <div style="overflow:auto">
        <table class="table mono" id="tblSpec"></table>
      </div>
    </div>
  </div>

<script>
// ---------- Safe DOM helpers ----------
const $ = (id)=>document.getElementById(id)
function getEl(id){ const el=document.getElementById(id); if(!el){ console.error(`[DOM] Missing #${id}`); } return el }
function getVal(id, def=null){ const el=getEl(id); return (el && 'value' in el)? el.value : def }
function setVal(id, v){ const el=getEl(id); if(el && 'value' in el){ el.value=v } }
function setHTML(id, html){ const el=getEl(id); if(el){ el.innerHTML=html } }
function showError(msg){ const box=getEl('errBox'); if(box){ box.style.display='block'; box.textContent=msg } }

// ---------- Parsers & math ----------
const parseList = (txt)=> String(txt||'').split(/[\\n,]+/).map(s=>s.trim()).filter(Boolean).map(Number)
const clamp = (x,a,b)=> Math.max(a, Math.min(b, x))
function oddsScale(p, lam){ p = clamp(p,0,1-1e-12); const odds=p/(1-p); const o2=lam*odds; return clamp(o2/(1+o2),0,1) }
function afterProbs(pFail){ const out=[]; let acc=1; for(const pf of pFail){ acc*=(1-pf); out.push(acc) } return out }
function evCurve(reward, pFail, capMult){ const after=afterProbs(pFail); const rm=reward.map(r=> capMult? Math.min(r,capMult): r); return {ev: rm.map((r,i)=> r*after[i]), after} }
function argmax(arr){ let bi=0,bv=-Infinity; arr.forEach((v,i)=>{ if(v>bv){bv=v;bi=i} }); return bi }
function toCSV(rows){ return rows.map(r=> r.map(v=> (typeof v==="number"? String(v): String(v))).join(",")).join("\\n") }
function download(name, text){ const blob=new Blob([text],{type:"text/csv;charset=utf-8"}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(url),5000) }
function fmt(x){ return Number(x).toFixed(6) }

// ---------- Defaults ----------
const defaultRewards=[1.05,1.12,1.21,1.32,1.45,1.60,1.77,1.96,2.18,2.50,2.75,3.05,3.40,3.80,4.25,4.75,5.30,5.90,6.55,10.00,11.20,12.50,13.90,15.40,17.00,18.70,20.50,22.40,24.40,50.00,58.00,66.00,74.00,82.00,90.00,98.00,106.00,114.00,122.00,300.00,400.00,550.00,750.00,1000.00,2000.00,4000.00,8000.00,20000.00,50000.00,100000.00]
const defaultBaseFailPct=[0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,0.95,1.00,1.20,1.40,1.60,1.80,2.00,2.20,2.40,2.60,2.80,3.00,3.50,4.00,4.50,5.00,5.50,6.00,6.50,7.00,7.50,8.00,9.00,10.00,11.00,12.00,13.00,14.00,15.00,16.00,18.00,20.00,22.00,25.00,30.00,35.00,40.00,45.00,50.00,60.00,70.00] // 49 entries

function loadDefaults(){ setVal('inpRewards', defaultRewards.join(',')); setVal('inpBaseFail', defaultBaseFailPct.join(',')) }

// ---------- Calibration (base + caps) ----------
let lastCalib=null
function calibrate(){
  const target=Number(getVal('inpTarget',0.96))||0.96
  const rewards=parseList(getVal('inpRewards',''))
  const baseFailPct=parseList(getVal('inpBaseFail',''))
  const s50=clamp(Number(getVal('inpS50',0.7))||0.7,0,1)
  if(rewards.length!==50){ alert('倍率需要 50 個數值'); return }
  if(baseFailPct.length!==49){ alert('基準失敗率需 49 個（第 50 步由成功率推）'); return }
  const baseFail=baseFailPct.map(x=>x/100); baseFail.push(1-s50)
  const moneyCap=Number(getVal('inpMoneyCap',50000))||50000
  const multCap=Number(getVal('inpMultCap',5000))||5000
  const capMultEffective=Math.min(multCap, moneyCap/1.0)
  let lo=0.1,hi=200.0,best={gap:1e9,lam:null,p:null,ev:null,after:null}
  for(let i=0;i<40;i++){
    const mid=0.5*(lo+hi)
    const p=baseFail.map(p0=>oddsScale(p0,mid))
    const {ev,after}=evCurve(rewards,p,capMultEffective)
    const gap=Math.abs(Math.max(...ev)-target)
    if(gap<best.gap) best={gap,lam:mid,p,ev,after}
    if(Math.max(...ev)>target) lo=mid; else hi=mid
  }
  const bestStep=argmax(best.ev)+1
  setHTML('calibKPI',`
    <div><div class="muted">lambda*</div><div class="kpi">${fmt(best.lam)}</div></div>
    <div><div class="muted">最佳步</div><div class="kpi">${bestStep}</div></div>
    <div><div class="muted">Max EV</div><div class="kpi">${fmt(Math.max(...best.ev))}</div></div>
    <div><div class="muted">有效倍率上限</div><div class="kpi">${fmt(capMultEffective)}x</div></div>`)
  const rows=[[ 'Step','Reward','FailProb','Survival','ReachProb(before)','AfterProb(through)','EV_at_step','Alert(>0.96)' ]]
  for(let k=0;k<50;k++){
    const reach=k===0?1.0:best.after[k-1]
    rows.push([k+1,fmt(rewards[k]),fmt(best.p[k]),fmt(1-best.p[k]),fmt(reach),fmt(best.after[k]),fmt(best.ev[k]), best.ev[k]>target?1:0])
  }
  const html=rows.map((r,i)=>'<tr>'+r.map(c=>(i?'<td>':'<th>')+c+(i?'</td>':'</th>')).join('')+'</tr>').join('')
  setHTML('tblSpec', html)
  lastCalib={rewards,baseFail,target,moneyCap,multCap,capMultEffective,...best}
}

// ---------- CSV Exports ----------
function exportSpec(){ if(!lastCalib){ alert('請先執行自動校準'); return } const {rewards,p,after,ev,target}=lastCalib; const rows=[[ 'Step','RewardMultiplier',`ScaledFailProb(odds,lambda=${fmt(lastCalib.lam)})`,'ScaledSurvivalProb','ReachProb(before step)','AfterProb(through step)','EV_at_step(with caps)','Alert(>target)']]; for(let k=0;k<50;k++){ const reach=k===0?1.0:after[k-1]; rows.push([k+1,rewards[k],p[k],1-p[k],reach,after[k],ev[k],ev[k]>target?1:0]) } download('VaultHeist_Probability_Spec_withCaps.csv', toCSV(rows)) }
function exportAlerts(){ if(!lastCalib){ alert('請先執行自動校準'); return } const {rewards,ev,target}=lastCalib; const rows=[[ 'Step','RewardMultiplier','EV_at_step(with caps)' ]]; ev.forEach((v,i)=>{ if(v>target) rows.push([i+1,rewards[i],v]) }); download('VaultHeist_Alert_Report.csv', toCSV(rows)) }

// ---------- Advanced (items + curve breakers) ----------
function getCfg(){ return { canvas_prob:Number(getVal('inpCanvasProb',0))||0, canvas_bonus:Number(getVal('inpCanvasBonus',0))||0, landmark_prob:Number(getVal('inpLandmarkProb',0))||0, landmark_fail:Number(getVal('inpLandmarkFail',0))||0, landmark_bonus:Number(getVal('inpLandmarkBonus',0))||0, lookout_cost_mult:Number(getVal('inpLookoutCost',0))||0, drone_cost_mult:Number(getVal('inpDroneCost',0))||0, nozzle_cost_mult:Number(getVal('inpNozzleCost',0))||0, template_cost_mult:Number(getVal('inpTemplateCost',0))||0, money_cap:Number(getVal('inpMoneyCap',50000))||50000, mult_cap:Number(getVal('inpMultCap',5000))||5000, alpha_by_bet:Number(getVal('inpAlphaByBet',0.5))||0.5, min_fail_after_45:Number(getVal('inpMinFailAfter45',0.35))||0.35, post40_abs_bump:Number(getVal('inpPost40Bump',0.05))||0.05 } }
function applyZoneLambda(baseFail,lam1,lam2,lam3){ const cfg=getCfg(); const p=baseFail.slice(); for(let i=39;i<=48;i++) p[i]=clamp(p[i]+cfg.post40_abs_bump,0,1); for(let i=0;i<50;i++){ const lam=i<30?lam1:(i<40?lam2:lam3); p[i]=oddsScale(p[i],lam) } for(let i=44;i<=48;i++) p[i]=Math.max(p[i],cfg.min_fail_after_45); return p }
function effectiveMult(mult,bet){ const cfg=getCfg(); const caps=[cfg.money_cap/bet, cfg.mult_cap, cfg.alpha_by_bet*(cfg.money_cap/bet)]; return Math.min(mult,...caps) }
function bestStopNoItems(pFail,bet){ const cap=effectiveMult(1e9,bet); const {ev}=evCurve(defaultRewards,pFail,cap); return argmax(ev)+1 }
function simulateRound(bet,pFail,rng){ const cfg=getCfg(); let lookout=1,drone=1,nozzle=1,template=1; let cost=0,step=0,alive=true,mult=1.0,bonus=0.0,droneBuf=0; const stop=bestStopNoItems(pFail,bet); while(alive&&step<stop){ const next=step+1; if(template>0&&next===35){ template--; cost+=cfg.template_cost_mult*bet; step=38; mult=defaultRewards[step-1]; continue } const isCanvas=(next<=35)&&(rng()<cfg.canvas_prob); const isLandmark=(next>=28&&next<=44)&&(rng()<cfg.landmark_prob); if(drone>0&&(next===41||next===43||next===45)&&!isLandmark){ droneBuf=1; drone--; cost+=cfg.drone_cost_mult*bet } const stepFail=isLandmark?cfg.landmark_fail:pFail[next-1]; const effFail=(droneBuf===1&&!isLandmark)?0.0:stepFail; if(droneBuf===1&&!isLandmark) droneBuf=0; if(rng()<effFail){ if(lookout>0){lookout--; cost+=cfg.lookout_cost_mult*bet} else { alive=false; break } } else { step=next; mult=defaultRewards[step-1]; if(isCanvas) mult+=cfg.canvas_bonus; if(isLandmark) bonus+=cfg.landmark_bonus; if(nozzle>0&&step===45&&!isLandmark){ nozzle--; cost+=cfg.nozzle_cost_mult*bet; mult*=2.0 } } } let payout=0; if(alive&&step>=1){ let total=mult+bonus; total=effectiveMult(total,bet); payout=total*bet } return Math.max(0,payout-cost) }
function runAdvanced(){ try{ const bet=Number(getVal('inpBet',1))||1; const sims=Number(getVal('inpSims',20000))||20000; const lam1=Number(getVal('inpLam1',1.0))||1.0; const lam2=Number(getVal('inpLam2',1.12))||1.12; const lam3=Number(getVal('inpLam3',2.5))||2.5; const rewards=parseList(getVal('inpRewards','')); const baseFailPct=parseList(getVal('inpBaseFail','')); const s50=clamp(Number(getVal('inpS50',0.7))||0.7,0,1); if(rewards.length!==50||baseFailPct.length!==49){ alert('請先正確填入倍率與失敗率'); return } const baseFail=baseFailPct.map(x=>x/100); baseFail.push(1-s50); const pFail=applyZoneLambda(baseFail,lam1,lam2,lam3); let sum=0,sum2=0; const rng=Math.random; for(let i=0;i<sims;i++){ const v=simulateRound(bet,pFail,rng); sum+=v; sum2+=v*v } const mean=sum/sims; const std=Math.sqrt(Math.max(0,sum2/sims-mean*mean)); const rtp=(sum/(bet*sims)); const cls=rtp>0.965?'warn':(rtp<0.955?'warn':'ok'); setHTML('advResult',`<div><div class="muted">RTP</div><div class="kpi ${cls}">${fmt(rtp)}</div></div><div><div class="muted">Mean payout</div><div class="kpi">$${fmt(mean)}</div></div><div><div class="muted">Std payout</div><div class="kpi">$${fmt(std)}</div></div>`)}catch(err){ console.error(err); alert('進階模擬執行時發生錯誤，請檢查輸入或參數。') } }
function runOnceRTP(bet,lam1,lam2,lam3,sims){ const rewards=parseList(getVal('inpRewards','')); const baseFailPct=parseList(getVal('inpBaseFail','')); const s50=clamp(Number(getVal('inpS50',0.7))||0.7,0,1); const baseFail=baseFailPct.map(x=>x/100); baseFail.push(1-s50); const pFail=applyZoneLambda(baseFail,lam1,lam2,lam3); let sum=0; const rng=Math.random; for(let i=0;i<sims;i++) sum+=simulateRound(bet,pFail,rng); return sum/(bet*sims) }
function calibrateAdvanced(){ const bet=Number(getVal('inpBet',1))||1; const simsCoarse=10000; const simsFine=25000; const target=Number(getVal('inpTarget',0.96))||0.96; const grid1=[0.8,1.0,1.2,1.4]; const grid2=[1.0,1.1,1.2,1.3,1.4]; const grid3=[1.5,2.0,2.5,3.0]; let best={gap:1e9,l1:1.0,l2:1.12,l3:2.5,rtp:null}; for(const l1 of grid1){ for(const l2 of grid2){ for(const l3 of grid3){ const r=runOnceRTP(bet,l1,l2,l3,simsCoarse); const g=Math.abs(r-target); if(g<best.gap) best={gap:g,l1,l2,l3,rtp:r} } } } function neigh(x){ return [x*0.9,x*0.95,x,x*1.05,x*1.1] } for(let iter=0; iter<3; iter++){ for(const key of ['l1','l2','l3']){ const cand=neigh(best[key]); for(const v of cand){ const r=runOnceRTP(bet, key==='l1'?v:best.l1, key==='l2'?v:best.l2, key==='l3'?v:best.l3, simsFine); const g=Math.abs(r-target); if(g<best.gap) best={gap:g,l1:(key==='l1'?v:best.l1),l2:(key==='l2'?v:best.l2),l3:(key==='l3'?v:best.l3),rtp:r} } } } setVal('inpLam1',best.l1.toFixed(4)); setVal('inpLam2',best.l2.toFixed(4)); setVal('inpLam3',best.l3.toFixed(4)); setHTML('advResult',`<div><div class="muted">Calibrated λ</div><div class="kpi">${best.l1.toFixed(3)} / ${best.l2.toFixed(3)} / ${best.l3.toFixed(3)}</div></div><div><div class="muted">RTP</div><div class="kpi">${fmt(best.rtp)}</div></div>`) }

// ---------- Share URL & README ----------
function syncToURL(){ const params=new URLSearchParams(); ['inpTarget','inpS50','inpMoneyCap','inpMultCap','inpBet','inpSims','inpLam1','inpLam2','inpLam3'].forEach(id=> params.set(id, getVal(id,''))); params.set('rewards', getVal('inpRewards','')); params.set('baseFail', getVal('inpBaseFail','')); ['inpCanvasProb','inpCanvasBonus','inpLandmarkProb','inpLandmarkFail','inpLandmarkBonus','inpLookoutCost','inpDroneCost','inpNozzleCost','inpTemplateCost','inpPost40Bump','inpMinFailAfter45','inpAlphaByBet'].forEach(id=> params.set(id, getVal(id,''))); const url=location.origin+location.pathname+'?'+params.toString(); navigator.clipboard.writeText(url).then(()=> alert('已複製目前設定的分享連結')) }
function loadFromURL(){ const q=new URLSearchParams(location.search); ['inpTarget','inpS50','inpMoneyCap','inpMultCap','inpBet','inpSims','inpLam1','inpLam2','inpLam3'].forEach(id=>{ if(q.has(id)) setVal(id,q.get(id)) }); if(q.has('rewards')) setVal('inpRewards', q.get('rewards')); if(q.has('baseFail')) setVal('inpBaseFail', q.get('baseFail')); ['inpCanvasProb','inpCanvasBonus','inpLandmarkProb','inpLandmarkFail','inpLandmarkBonus','inpLookoutCost','inpDroneCost','inpNozzleCost','inpTemplateCost','inpPost40Bump','inpMinFailAfter45','inpAlphaByBet'].forEach(id=>{ if(q.has(id)) setVal(id,q.get(id)) }) }
function openReadme(){ fetch('https://cooperfu615-desinger.github.io/gk-sim-web/README.md').then(r=>r.text()).then(txt=>{ const w=window.open(); w.document.write('<pre style="white-space:pre-wrap;font-family:monospace">'+txt.replace(/[&<>]/g,s=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[s]))+'</pre>') }).catch(err=>alert('找不到 README.md，請確認是否與本頁同層。')) }

// ---------- Wire up & Self-tests ----------
document.addEventListener('DOMContentLoaded', ()=>{
  const requiredIds=['inpBet','inpSims','inpLam1','inpLam2','inpLam3','inpRewards','inpBaseFail','inpS50','inpTarget','inpMoneyCap','inpMultCap','btnRunAdv','btnCalibrate','btnCalibAdv','btnExportSpec','btnExportAlerts','btnShare','btnReset','btnReadme']
  const missing=requiredIds.filter(id=>!$(id))
  if(missing.length){ showError('缺少必要的 DOM 元件：'+missing.join(', ')); console.error('[BOOT] Missing', missing); return }

  // 初始化：填入預設值（包含倍率與失敗率清單）
  loadDefaults();
  loadFromURL();

  // 綁定
  getEl('btnCalibrate').onclick=calibrate
  getEl('btnExportSpec').onclick=exportSpec
  getEl('btnExportAlerts').onclick=exportAlerts
  getEl('btnRunAdv').onclick=runAdvanced
  getEl('btnCalibAdv').onclick=calibrateAdvanced
  getEl('btnShare').onclick=syncToURL
  getEl('btnReset').onclick=()=>{ loadDefaults(); const d={inpTarget:0.96,inpS50:0.7,inpMoneyCap:50000,inpMultCap:5000,inpBet:1,inpSims:20000,inpLam1:1.0,inpLam2:1.12,inpLam3:2.5}; Object.entries(d).forEach(([id,v])=> setVal(id,v)); const d2={inpCanvasProb:0.08,inpCanvasBonus:1.0,inpLandmarkProb:0.01,inpLandmarkFail:0.75,inpLandmarkBonus:1000,inpLookoutCost:0.5,inpDroneCost:0.5,inpNozzleCost:0.4,inpTemplateCost:0.6,inpPost40Bump:0.05,inpMinFailAfter45:0.35,inpAlphaByBet:0.5}; Object.entries(d2).forEach(([id,v])=> setVal(id,v)); setHTML('calibKPI',''); setHTML('tblSpec',''); setHTML('advResult','') }
  getEl('btnReadme').onclick=openReadme

  // 自我測試（不影響使用）
  try{
    const p0=0.2, lam=1.0; const p1=oddsScale(p0,lam); if(Math.abs(p1-p0)>1e-12) console.warn('Test1: oddsScale(.,1) not identity-ish')
    const af=afterProbs(Array(50).fill(0.1)); if(af.length!==50) console.error('Test2: afterProbs length wrong')
    calibrate(); if(!lastCalib) console.error('Test3: calibrate did not set lastCalib')
    const r=runOnceRTP(1,1.0,1.1,1.5,1000); if(!(r>0||r===0)) console.error('Test4: RTP not numeric')
    setVal('inpBet',1); setVal('inpSims',2000); runAdvanced(); if(!(getEl('advResult').innerHTML||'').length) console.warn('Test5: advResult empty')
  }catch(e){ console.error('[Self-tests] failed', e) }
})
</script>
</body>
</html>
